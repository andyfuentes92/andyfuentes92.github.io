<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>Register Allocation During Compilation: A Graph Coloring Approach</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="1561.4">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p6 {margin: 0.0px 0.0px 12.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #0000ee; -webkit-text-stroke: #0000ee}
    p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px 'Cambria Math'; color: #000000; -webkit-text-stroke: #000000}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 11.0px; font: 9.0px 'Cambria Math'; color: #000000; -webkit-text-stroke: #000000}
    p.p10 {margin: 0.0px 0.0px 12.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px AppleMyungjo; color: #000000; -webkit-text-stroke: #000000}
    p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Courier; color: #000000; -webkit-text-stroke: #000000}
    p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Courier; color: #000000; -webkit-text-stroke: #000000; min-height: 14.0px}
    p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 11.0px; font: 9.0px 'Cambria Math'; color: #000000; -webkit-text-stroke: #000000; min-height: 11.0px}
    li.li2 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    li.li8 {margin: 0.0px 0.0px 0.0px 0.0px; line-height: 14.0px; font: 12.0px 'Cambria Math'; color: #000000; -webkit-text-stroke: #000000}
    span.s1 {font-kerning: none}
    span.s2 {text-decoration: underline ; font-kerning: none}
    span.s3 {-webkit-text-stroke: 0px #000000}
    span.s4 {text-decoration: underline ; font-kerning: none; color: #0000ee; -webkit-text-stroke: 0px #0000ee}
    span.s5 {font: 12.0px Symbol; font-kerning: none}
    span.s6 {font: 12.0px Times; -webkit-text-stroke: 0px #000000}
    span.s7 {font: 12.0px Times; font-kerning: none}
    span.s8 {font: 9.0px 'Cambria Math'; font-kerning: none}
    span.s9 {font: 12.0px 'Lucida Grande'; font-kerning: none}
    ol.ol1 {list-style-type: decimal}
    ul.ul1 {list-style-type: disc}
  </style>
</head>
<body>
<p class="p1"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"> </span></p>
<h1 style="margin: 0.0px 0.0px 16.1px 0.0px; text-align: center; line-height: 28.0px; font: 24.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>The Edmonds-Karp Algorithm</b></span></h1>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; text-align: center; line-height: 22.0px; font: 18.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Theory</b></span></h2>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>IntroductionDadsfasdfasdf</b></span></h3>
<p class="p6"><span class="s1">Graph coloring algorithms serve as the backbone of register allocation during compiler optimization of code. A register is a memory location in the computer CPUs with an access time much faster than that of memory. Typically, two registers can be read and one written within one memory cycle, while accessing memory directly can take multiple memory cycles [2]. Due to the relatively small capacity of registers, as well as their importance in achieving fast computation speeds, optimizing register usage is a great way to increase the speeds of compiled programs. During compilation, values that are referenced often should be held in easy to access registers in order to maximize the efficiency of compilation. However, programs can be tremendously complex, and even the most up to date hardware has a limited number of registers. It is the job of register allocators to determine what data can be stored in registers, and what will need to be fetched directly from memory.<span class="Apple-converted-space"> </span></span></p>
<p class="p7"><span class="s2"><a href="http://dx.doi.org/10.1145/321694.321699"><i>Edmonds, Jack; Karp, Richard M. (1972). "Theoretical improvements in algorithmic efficiency for network flow problems". Journal of the ACM. Association for Computing Machinery. 19 (2): 248–264. doi:10.1145/321694.321699.</i></a></span></p>
<p class="p6"><span class="s1">The Edmonds-Karp Algorithm has a time complexity of:</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p9"><span class="s1">2</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">E</span></p>
<p class="p8"><span class="s1">)</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Flow Network</b></span></h3>
<p class="p6"><span class="s1">A <b>Flow Network</b> is a directed graph, where each edge has a maximum flow <b>capacity</b>. Each edge can receive some amount of flow as long as that flow is less than or equal to that edge's capacity. The vertices in a flow network are called <b>nodes</b>. The edges are called <b>links</b> or <b>arcs</b>. Every flow network contains a <b>source</b> and <b>sink</b> node. A <b>source</b> node only contains outgoing links to the network and can be thought of as having an infinite supply. A <b>sink</b> node's flow output is only limited by the network. With the exception for source and sink nodes, the amount of flow entering a node must equal the amount of flow leaving the node.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">∑</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">p</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">∑</span></p>
<p class="p8"><span class="s1">o</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">p</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p6"><span class="s1"><b>The Flow Network Problem:</b></span></p>
<p class="p6"><span class="s1">We are given:<span class="Apple-converted-space"> </span></span></p>
<ul class="ul1">
  <li class="li2"><span class="s3"></span><span class="s1">A directed graph with a set of edges and vertices<span class="Apple-converted-space"> </span></span></li>
  <li class="li2"><span class="s3"></span><span class="s1">A source vertex capable of providing infinite flow<span class="Apple-converted-space"> </span></span></li>
  <li class="li2"><span class="s3"></span><span class="s1">A target/sink vertex that we wish to measure the maximum flow output<span class="Apple-converted-space"> </span></span></li>
  <li class="li2"><span class="s3"></span><span class="s1">Every edge has a capacity limit</span></li>
</ul>
<p class="p10"><span class="s1"></span><br></p>
<p class="p6"><span class="s1"><b>Goal:</b> We want to find the actual flow through the network so that we maximize the output at the sink node. Let S be the source node, T be the target/sink node, and v be some vertex.</span></p>
<p class="p6"><span class="s1">Flow Value =</span></p>
<p class="p8"><span class="s1">∑</span></p>
<p class="p9"><span class="s1">a</span></p>
<p class="p9"><span class="s1">l</span></p>
<p class="p9"><span class="s1">l</span></p>
<p class="p9"><span class="s1"> </span></p>
<p class="p9"><span class="s1">v</span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">S</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">∑</span></p>
<p class="p9"><span class="s1">a</span></p>
<p class="p9"><span class="s1">l</span></p>
<p class="p9"><span class="s1">l</span></p>
<p class="p9"><span class="s1"> </span></p>
<p class="p9"><span class="s1">v</span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">T</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1"><b>Our constraints</b></span></p>
<p class="p6"><span class="s1">The flow through an edge is limited by the edge's capacity constraint:</span></p>
<p class="p8"><span class="s1">L</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">x</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">y</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p8"><span class="s1">q</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">l</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">p</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">y</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">o</span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">g</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">x</span></p>
<p class="p8"><span class="s1">y</span></p>
<p class="p9"><span class="s1">→</span></p>
<p class="p1"><span class="s1"></span><br></p>
<p class="p8"><span class="s1">L</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">x</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">y</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p8"><span class="s1">q</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">l</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">l</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1">l</span></p>
<p class="p8"><span class="s1">o</span></p>
<p class="p8"><span class="s1">w</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">g</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p8"><span class="s1"> </span></p>
<p class="p8"><span class="s1">x</span></p>
<p class="p8"><span class="s1">y</span></p>
<p class="p9"><span class="s1">→</span></p>
<p class="p1"><span class="s1"></span><br></p>
<p class="p8"><span class="s1">0</span></p>
<p class="p8"><span class="s1">≤</span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">x</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">y</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">≤</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">x</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">y</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">Flow conservation:</span></p>
<p class="p6"><span class="s1">For all</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">≠</span></p>
<p class="p8"><span class="s1">S</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">T</span></p>
<p class="p8"><span class="s1">∑</span></p>
<p class="p9"><span class="s1">a</span></p>
<p class="p9"><span class="s1">l</span></p>
<p class="p9"><span class="s1">l</span></p>
<p class="p9"><span class="s1"> </span></p>
<p class="p9"><span class="s1">v</span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">∑</span></p>
<p class="p9"><span class="s1">a</span></p>
<p class="p9"><span class="s1">l</span></p>
<p class="p9"><span class="s1">l</span></p>
<p class="p9"><span class="s1"> </span></p>
<p class="p9"><span class="s1">v</span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1"><b>Observations and Simplifications:</b></span></p>
<p class="p6"><span class="s1"><i>Cycles:</i> If a cycle has flow on all edges, then we can get an equivalent solution with greater than or equal to one of the edges having zero flow. Why send product (flow) in a cycle with positive flow?<br>
Notice: Any edge</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">S</span></p>
<p class="p9"><span class="s1">→</span></p>
<p class="p6"><span class="s1">must be part of a cycle. Any solution has an equivalent with</span></p>
<p class="p8"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">S</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">0</span></p>
<p class="p6"><span class="s1"><i>Sinks:</i> Any vertex, other than our target sink node, which contains <b>only</b> incoming edges can be removed. In this circumstance flow would never make it to the target node.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Applications</b></span></h3>
<p class="p6"><span class="s1">Some applications where it is desirable to find the maximum flow through a network are:<span class="Apple-converted-space"> </span></span></p>
<ul class="ul1">
  <li class="li2"><span class="s3"></span><span class="s1">Modeling traffic in a road system</span></li>
  <li class="li2"><span class="s3"></span><span class="s1">Fluids in pipes</span></li>
  <li class="li2"><span class="s3"></span><span class="s1">Currents flowing through an electical circuit</span></li>
</ul>
<p class="p2"><span class="s1">The following paper describes some applications of the maximum flow network problem: <a href="http://theory.stanford.edu/~tim/w16/l/l4.pdf"><span class="s4">link</span></a></span></p>
<p class="p10"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Residual Graph</b></span></h3>
<p class="p6"><span class="s1">The residual graph is a tool used in the maximum flow calculations that helps us determine how much you can change in the original graph.</span></p>
<p class="p6"><span class="s1"><b>Definition:</b> Given a network</span></p>
<p class="p8"><span class="s1">G</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">E</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">and a flow f, the <i>residual graph</i> r G = ( V </span><span class="s5">′</span><span class="s1"> , E </span><span class="s5">′</span><span class="s1"> ) of graph G with respect to the flow f is:<span class="Apple-converted-space"> </span></span></p>
<ul class="ul1">
  <li class="li2"><span class="s3"></span><span class="s1">V' = V<span class="Apple-converted-space"> </span></span></li>
  <li class="li8"><span class="s6"><b></b></span><span class="s7"><b>Forward Edges:</b> For each edge </span><span class="s1">e<br>
∈<br>
E<br>
<br>
<br>
</span><span class="s7">with </span><span class="s1">f<br>
(<br>
e<br>
)<br>
<br>
&lt;<br>
c<br>
(<br>
e<br>
)<br>
<br>
<br>
<br>
</span><span class="s7">, </span><span class="s1">e<br>
∈<br>
E<br>
</span><span class="s8">′<br>
</span><span class="s1"><br>
<br>
<br>
</span><span class="s7">with capacity </span><span class="s1">c<br>
(<br>
e<br>
)<br>
<br>
−<br>
f<br>
(<br>
e<br>
)<br>
<br>
<br>
<br>
</span><span class="s7">.<span class="Apple-converted-space"> </span></span></li>
  <li class="li8"><span class="s6"><b></b></span><span class="s7"><b>Backward Edges:</b> For each edge </span><span class="s1">e<br>
=<br>
(<br>
u<br>
,<br>
v<br>
)<br>
<br>
∈<br>
E<br>
<br>
<br>
</span><span class="s7">with </span><span class="s1">f<br>
(<br>
e<br>
)<br>
<br>
&gt;<br>
0<br>
<br>
<br>
</span><span class="s7">, </span><span class="s1">(<br>
v<br>
,<br>
u<br>
)<br>
<br>
∈<br>
E<br>
</span><span class="s8">′<br>
</span><span class="s1"><br>
<br>
<br>
</span><span class="s7">with capacity </span><span class="s1">f<br>
(<br>
e<br>
)<br>
<br>
<br>
<br>
</span><span class="s7">.<span class="Apple-converted-space"> </span></span></li>
</ul>
<p class="p2"><span class="s1">The following diagram represents the graph at a specific iteration of the maximum flow calcuations. Each edge is annotated with the flow/capacity values.</span></p>
<p class="p10"><span class="s1"></span><br></p>
<p class="p2"><span class="s1">11 / 16</span></p>
<p class="p2"><span class="s1">8 / 13</span></p>
<p class="p2"><span class="s1">12 / 12</span></p>
<p class="p2"><span class="s1">11 / 14</span></p>
<p class="p2"><span class="s1">1 / 4</span></p>
<p class="p2"><span class="s1">7 / 7</span></p>
<p class="p2"><span class="s1">4 / 9</span></p>
<p class="p2"><span class="s1">15 / 20</span></p>
<p class="p2"><span class="s1">4 / 4</span></p>
<p class="p2"><span class="s1">s</span></p>
<p class="p2"><span class="s1">t</span></p>
<p class="p2"><span class="s1">v1</span></p>
<p class="p2"><span class="s1">v2</span></p>
<p class="p2"><span class="s1">v3</span></p>
<p class="p2"><span class="s1">v4</span></p>
<p class="p6"><span class="s1">The residual graph is constructed by creating a new graph with identical edges to the original graph. The weights on the edges in this graph represent the residual capacity available on each edge at the current instance of time during the maximum flow calculations. The residual flow is simply the edge capacity minus the edge flow. Edges with an edge capcity equal to 0 can be elimnated from the graph.<span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1">5</span></p>
<p class="p2"><span class="s1">5</span></p>
<p class="p2"><span class="s1">3</span></p>
<p class="p2"><span class="s1">3</span></p>
<p class="p2"><span class="s1">5</span></p>
<p class="p2"><span class="s1">5</span></p>
<p class="p2"><span class="s1">s</span></p>
<p class="p2"><span class="s1">t</span></p>
<p class="p2"><span class="s1">v1</span></p>
<p class="p2"><span class="s1">v2</span></p>
<p class="p2"><span class="s1">v3</span></p>
<p class="p2"><span class="s1">v4</span></p>
<p class="p6"><span class="s1">We then create a new graph containing all the original edges but with their directions reversed. Each of these edges contain weights equal to the current flow rates. Any edges that have a weight of zero can be removed.<span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1">11</span></p>
<p class="p2"><span class="s1">8</span></p>
<p class="p2"><span class="s1">12</span></p>
<p class="p2"><span class="s1">11</span></p>
<p class="p2"><span class="s1">1</span></p>
<p class="p2"><span class="s1">7</span></p>
<p class="p2"><span class="s1">4</span></p>
<p class="p2"><span class="s1">15</span></p>
<p class="p2"><span class="s1">4</span></p>
<p class="p2"><span class="s1">s</span></p>
<p class="p2"><span class="s1">t</span></p>
<p class="p2"><span class="s1">v1</span></p>
<p class="p2"><span class="s1">v2</span></p>
<p class="p2"><span class="s1">v3</span></p>
<p class="p2"><span class="s1">v4</span></p>
<p class="p6"><span class="s1">These two graphs are then merged together to produce the <b>Residual Graph</b></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Augmenting Paths</b></span></h3>
<p class="p6"><span class="s1">An Augmenting path is any path from the source to the sink that can currently take more flow. The method for finding an augmenting path is the key feature of the Edmonds-Karp Algorithm. The Edmonds-Karp algorithm uses a Breadth First Search (BFS) to find the augmenting path. Over the course of the algorithm, flow is monotonically increased. There are instances where a path from the source to the sink can take on more flow, and that is an augmenting path.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">The Residual Network contains all potential flow changes. Every edge in the network is represented in the Residual Network at lease once. Any directed path from source to sink in the Residual Network means we improve the solution. Once we find an augmenting path, we find the smallest weight on that path and use that value to increase the flow. This value is added to edges in the Flow Network if the edge in the Residual Graph is a forward edge. This value is subtracted from edges in the Flow Network if the edge is the Residual Graph is a backward edge. We then regenerate the Residual Graph and repeat until we no longer find an augmenting path.<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Maximum Flow and Minimum Cut</b></span></h3>
<p class="p2"><span class="s1"><b>Theorem</b></span></p>
<p class="p6"><span class="s4"><a href="https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem">maximum-flow minimum-cut theorem</a></span><span class="s1"> states that The maximum flow through any network from a given source to a given sink is exactly the sum of the edge weights that, if removed, would totally disconnect the source from the sink.</span></p>
<p class="p1"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"><b>So what is a flow?</b></span></p>
<p class="p6"><span class="s1">A flow can be anything.<span class="Apple-converted-space"> </span></span></p>
<ul class="ul1">
  <li class="li2"><span class="s3"></span><span class="s1">It could be data that passes through an Information Technology (IT) network.</span></li>
  <li class="li2"><span class="s3"></span><span class="s1">It could be packages that need to be shipped from source to destination.</span></li>
  <li class="li2"><span class="s3"></span><span class="s1">It could be automobiles traveling through a network of roads.</span></li>
</ul>
<p class="p10"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"><b>What does a Flow Network Diagram look like?</b></span></p>
<p class="p6"><span class="s1">The simplest of all Flow Network Diagrams appears in the figure below. There exist two nodes, a source, labeled s, and a sink, labeled t. The source and sink nodes are connected by a single edge. The edge is labeled with the flow rate on that edge and the maximum flow capacity allowed across that edge. In this example, the flow rate is 0 and the maximum capacity of the link is 1 and is represented in the form 0/1.<span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1">0 / 1</span></p>
<p class="p2"><span class="s1">Cut</span></p>
<p class="p2"><span class="s1">s</span></p>
<p class="p2"><span class="s1">t</span></p>
<p class="p6"><span class="s1">In this Flow Network Diagram, there exists only one edge with a capacity of 1 from the source node to the target node. The maximum flow is equal to the minimum cut through the Flow Network, which can easily be seen to have a value of 1.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">The next simple example adds a node in between the source and target with no direct link from source to target. This means the the flow must travel through this node to get to the target. We can then demonstrate the minimum cut is still 1 in this example since the edge from a to t produces the smallest cut that separates the source from the target.<span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1">0 / 2</span></p>
<p class="p2"><span class="s1">0 / 1</span></p>
<p class="p2"><span class="s1">Cut</span></p>
<p class="p2"><span class="s1">s</span></p>
<p class="p2"><span class="s1">t</span></p>
<p class="p2"><span class="s1">a</span></p>
<p class="p6"><span class="s1">A s-t cut partitions the vertices, V, of a graph into two sets, S and T, where the source node <i>s</i> </span><span class="s5">∈</span><span class="s1"> <i>S</i> and the sink or target node <i>t</i> </span><span class="s5">∈</span><span class="s1"> <i>T</i>. Furthermore the cut set contains all edges that cross from a node in set S to a node in set T.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1"><b>Claim</b>: A <i>minimum cut-set</i> is a s-t cut whose capacity is minimal.</span></p>
<p class="p6"><span class="s1"><b>Proof:</b></span></p>
<p class="p6"><span class="s1">Let G = (V, E) be a directed graph with s=source node and t=sink node of G respectively.</span></p>
<p class="p6"><span class="s1">Now consider the calculated flow=f</span><span class="s9"> </span><span class="s1">for G by the Flow Network method. In the residual graph (rG) that is calculated from G after the final flow assignment is generated by the Flow Network method, we can divide the vertices into two subsets:<span class="Apple-converted-space"> </span></span></p>
<ol class="ol1">
  <li class="li2"><span class="s3"></span><span class="s1">A: the set of vertices reachable from s in rG<span class="Apple-converted-space"> </span></span></li>
  <li class="li2"><span class="s3"></span><span class="s1">B: the set of remaining vertices. In other words, B = V − A<span class="Apple-converted-space"> </span></span></li>
</ol>
<p class="p10"><span class="s1"></span><br></p>
<p class="p6"><span class="s1"><b>Claim:</b> f = c(A, B), where the flow is equal to the capacity of the s-t cut.</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">S</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">T</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">∑</span></p>
<p class="p9"><span class="s1">(</span></p>
<p class="p9"><span class="s1">u</span></p>
<p class="p9"><span class="s1">,</span></p>
<p class="p9"><span class="s1">v</span></p>
<p class="p9"><span class="s1">)</span></p>
<p class="p9"><span class="s1">∈</span></p>
<p class="p9"><span class="s1">S</span></p>
<p class="p9"><span class="s1">x</span></p>
<p class="p9"><span class="s1">T</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p9"><span class="s1">u</span></p>
<p class="p9"><span class="s1">v</span></p>
<p class="p6"><span class="s1">Given that the flow out from the subset A minus the flow in from the subset A equals the flow for any subset of vertices, A. We need the value of f = c(A, B) to be:<span class="Apple-converted-space"> </span></span></p>
<ul class="ul1">
  <li class="li2"><span class="s3"></span><span class="s1">All outgoing edges from the cut to be fully saturated.<span class="Apple-converted-space"> </span></span></li>
  <li class="li2"><span class="s3"></span><span class="s1">All incoming edges to the cut to have zero flow.<span class="Apple-converted-space"> </span></span></li>
</ul>
<p class="p10"><span class="s1"></span><br></p>
<p class="p6"><span class="s1">Let's consider the following cases:<span class="Apple-converted-space"> </span></span></p>
<ul class="ul1">
  <li class="li2"><span class="s3"></span><span class="s1">In graph G, there exists an outgoing edge (x,y) and x is a member of subset A and y is a member of subset B. Let this edge not be saturated. If this is the case, then there must exist a <b>forward edge</b> from x to y in rG. This implies there is a path from S to y in rG, which is a <b>contradiction</b>. Therefore, all outgoing edges are fully saturated.<span class="Apple-converted-space"> </span></span></li>
  <li class="li2"><span class="s3"></span><span class="s1">In graph G, there exists an incoming edge (y,x) and x is a member of subset A and y is a member of subset B. Let this edge carry some non-zero flow. If this is the case, then ther must exist a <b>backward edge</b> from x to y in rG. This implies there is a path from S to y in rG, which is a <b>contradiction</b>. Therefore, all incoming edges must have zero flow.<span class="Apple-converted-space"> </span></span></li>
</ul>
<p class="p2"><span class="s1"><b>In conclusion:</b> The capacity of the cut obtained from the description above is equal to the flow obtained in the network.</span></p>
<p class="p10"><span class="s1"></span><br></p>
<p class="p11"><span class="s1">◻</span></p>
<p class="p10"><span class="s1"></span><br></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>The Edmonds-Karp Algorithm</b></span></h3>
<p class="p6"><span class="s1">The Edmonds-Karp Algorithm is a specific implementation of the <a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm"><span class="s4">Ford-Fulkerson method</span></a>. In particular, Edmonds-Karp algorithm implements the searching for an augmenting path using the Breadth First Search (BFS) algorithm. Other implementations of the Ford-Fulkerson method use the Depth First Search (DFS) algorithm to find augmenting paths.</span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Algorithm Pseudocode</b></span></h3>
<p class="p12"><span class="s1"><span class="Apple-converted-space">               </span><b>inputs</b></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>capacityMatrix[n x n] : Capacity Matrix</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>adjMatrix[n x n]<span class="Apple-converted-space">      </span>: Adjacency Matrix</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>src <span class="Apple-converted-space">                  </span>: Source</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>target<span class="Apple-converted-space">                </span>: sink or target</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">               </span><b>output</b><span class="Apple-converted-space"> </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>maxFlow <span class="Apple-converted-space">              </span>: Maximum Flow Rate</span></p>
<p class="p13"><span class="s1"></span><br></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">               </span><b>The Edmonds-Karp:</b></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>maxFlow = 0 <span class="Apple-converted-space">            </span>// Initialize the flow to 0</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>residualMatrix[n x n] <span class="Apple-converted-space">  </span>// The residual capacity array</span></p>
<p class="p13"><span class="s1"><span class="Apple-converted-space">  </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>while true:</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                    </span>min, augmentPath = BFS(capacityMatrix, adjMatrix, source, target, residualMatrix)</span></p>
<p class="p13"><span class="s1"><span class="Apple-converted-space">      </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                    </span>if m = 0:</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                      </span>break</span></p>
<p class="p13"><span class="s1"><span class="Apple-converted-space">                   </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                    </span>maxFlow = maxFlow + min</span></p>
<p class="p13"><span class="s1"><span class="Apple-converted-space">                   </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                    </span>// Walk the augmenting path<span class="Apple-converted-space"> </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                    </span>v = target</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                    </span>while v != src:</span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                      </span>u = P[v]<span class="Apple-converted-space"> </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                      </span>residualMatrix[u,v] = residualMatrix[u,v] - min // Reduce the residual capacity <span class="Apple-converted-space">           </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                      </span>residualMatrix[v,u] = residualMatrix[v,u] + min // Increase the residual capacity of reverse edges<span class="Apple-converted-space"> </span></span></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                      </span>v = u</span></p>
<p class="p13"><span class="s1"></span><br></p>
<p class="p12"><span class="s1"><span class="Apple-converted-space">                  </span>return maxFlow<span class="Apple-converted-space"> </span></span></p>
<p class="p13"><span class="s1"><span class="Apple-converted-space">               </span></span></p>
<p class="p6"><span class="s1">This algorithm code starts with the maximum flow initially set to 0. The while loop executes until there are no more augmenting paths. Within the while loop, we call BFS to find the shortest path from source to sink and the minimum residual capacity along that path, min. We then walk the augmenting path from target to source. Using the minium residual capacity, we reduce all residual capacities on the augmenting path by min and increase the residual capacities on the reverse edges (representing the flow).<span class="Apple-converted-space"> </span></span></p>
<h3 style="margin: 0.0px 0.0px 14.0px 0.0px; line-height: 17.0px; font: 14.0px Times; color: #000000; -webkit-text-stroke: #000000"><span class="s1"><b>Complexity Analysis</b></span></h3>
<p class="p6"><span class="s1">The Edmonds-Karp algorithm runs in</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">E</span></p>
<p class="p9"><span class="s1">2</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">In each iteration of the algorithm, the shortest path (BFS) between the source and all other vertices must increase monotonically. We need to prove that one iteration of the Edmonds-Karp algorithm is bounded by</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">E</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">. We then need to prove that the number of iterations of the algorithm to find the maximum flow of a network is bounded by</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">VE</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">iterations. Proving these two parts implies that the Edmonds-Karp algorithm is bounded by</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">E</span></p>
<p class="p9"><span class="s1">2</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1"><b>Proof:</b></span></p>
<p class="p6"><span class="s1"><i>Part 1:</i> Show that the for every vertex, v, the length of the shortest path from source to v must increase.</span></p>
<p class="p6"><span class="s1">This is a proof by <b>contradiction</b>.</span></p>
<p class="p6"><span class="s1">Consider a flow augmentation that causes the shortest path to decrease. Let f be the flow before such an augmentation and let f' be the flow just after. There must exist a vertex, v, such that:<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">&lt;</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">Now, suppose there is a shortest path from s to v that has to travel through vertex u in the residual graph. Let's assume the shortest path from s to v is 1 more the shortest path from s to u:</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">−</span></p>
<p class="p8"><span class="s1">1</span></p>
<p class="p6"><span class="s1">The shortest path from s to u did not decrease with the new flow as result of how we choose v, therefore:<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">≥</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">However, the edge (u,v) can not exist in the residual graph. Assuming we are using integer edge lengths, the following relationships would exist if the edge existed:<span class="Apple-converted-space"> </span></span></p>
<ol class="ol1">
  <li class="li8"><span class="s3"></span><span class="s1">d<br>
i<br>
s<br>
t<br>
a<br>
n<br>
c<br>
e<br>
</span><span class="s8">f<br>
<br>
</span><span class="s1"><br>
(<br>
s<br>
,<br>
v<br>
)<br>
<br>
≤<br>
d<br>
i<br>
s<br>
t<br>
a<br>
n<br>
c<br>
e<br>
</span><span class="s8">f<br>
<br>
</span><span class="s1"><br>
(<br>
s<br>
,<br>
u<br>
)<br>
<br>
+<br>
1<br>
<br>
<br>
</span><span class="s7">(triangle inequality) <br>
</span></li>
  <li class="li8"><span class="s3"></span><span class="s1">d<br>
i<br>
s<br>
t<br>
a<br>
n<br>
c<br>
e<br>
</span><span class="s8">f<br>
<br>
</span><span class="s1"><br>
(<br>
s<br>
,<br>
v<br>
)<br>
<br>
≤<br>
d<br>
i<br>
s<br>
t<br>
a<br>
n<br>
c<br>
e<br>
</span><span class="s8">f<br>
<br>
′<br>
<br>
<br>
<br>
<br>
</span><span class="s1"><br>
(<br>
s<br>
,<br>
u<br>
)<br>
<br>
+<br>
1<br>
<br>
<br>
</span><span class="s7">(shortest path decreases with f') <br>
</span></li>
  <li class="li8"><span class="s3"></span><span class="s1">d<br>
i<br>
s<br>
t<br>
a<br>
n<br>
c<br>
e<br>
</span><span class="s8">f<br>
<br>
</span><span class="s1"><br>
(<br>
s<br>
,<br>
v<br>
)<br>
<br>
≤<br>
d<br>
i<br>
s<br>
t<br>
a<br>
n<br>
c<br>
e<br>
</span><span class="s8">f<br>
<br>
′<br>
<br>
<br>
<br>
<br>
</span><span class="s1"><br>
(<br>
s<br>
,<br>
v<br>
)<br>
<br>
<br>
<br>
</span><span class="s7">(the relationship between (s,u) and (s,v) <br>
</span></li>
</ol>
<p class="p2"><span class="s1">The third relationship would be violated. The shortest path did not decrease with flow f'. A contradiction.</span></p>
<p class="p10"><span class="s1"></span><br></p>
<p class="p6"><span class="s1"><b>Recap:</b><br>
The shortest path increases monontonically in the residual graph. Therefore the length of one iteration is bounded in the Edmonds-Karp algorithm to O(E).<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1"><i>Part 2:</i> Show the bound on the number of iterations that the Edmonds-Karp algorithm must perform to find maximum flow.</span></p>
<p class="p6"><span class="s1">Let's define some terminolgy first:</span></p>
<p class="p10"><span class="s1"></span><br></p>
<p class="p6"><span class="s1"><b>Critical Edge:</b> is an edge on the augmenting path whose residual capacity equals the residual capacity of the path.<br>
</span></p>
<p class="p6"><span class="s1">Given an augmenting path with a critical edge, the critical edge's capacity will be filled by this augmenting path. Once this happens, the edge will be removed from the residual network. This proof will show that each edge of the graph's edge set can be critical at most</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">2</span></p>
<p class="p6"><span class="s1">times.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1">Let an edge in the graph be defined by the vertices u and v. Furthermore, let s be the source node in the graph. Now, when the edge is first considered to be critical, then the distance realtionship becomes:<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">+</span></p>
<p class="p8"><span class="s1">1</span></p>
<p class="p6"><span class="s1">When the flow is augmented, the edge (u,v) will disappear in the residual network. Now, for it to reappear, the flow from u to v must be decreased. This can only occur if the edge (v,u) appears on the augmenting path. Let f', be the flow when this situation occurs.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">=</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">+</span></p>
<p class="p8"><span class="s1">1</span></p>
<p class="p6"><span class="s1">From the proof in <i>Part 1</i>, we have the relationship of (s,u) and (s,v) defined by</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">≤</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">. We can then perform substitions to get:<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">≥</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">+</span></p>
<p class="p8"><span class="s1">1</span></p>
<p class="p6"><span class="s1">Now, during the time that edge (u,v) first became critical to when the it became critical again, the distance between the source and u increases by at least 2.<span class="Apple-converted-space"> </span></span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p14"><span class="s1"></span><br></p>
<p class="p9"><span class="s1">′</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">u</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">≥</span></p>
<p class="p8"><span class="s1">d</span></p>
<p class="p8"><span class="s1">i</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">t</span></p>
<p class="p8"><span class="s1">a</span></p>
<p class="p8"><span class="s1">n</span></p>
<p class="p8"><span class="s1">c</span></p>
<p class="p8"><span class="s1">e</span></p>
<p class="p9"><span class="s1">f</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">s</span></p>
<p class="p8"><span class="s1">,</span></p>
<p class="p8"><span class="s1">v</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p8"><span class="s1">+</span></p>
<p class="p8"><span class="s1">2</span></p>
<p class="p6"><span class="s1">The itermediate vertices on the shortest path from s to u cannot contain vertices s, u, or t. Therefore, the distance to vertex u is at most</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">−</span></p>
<p class="p8"><span class="s1">2</span></p>
<p class="p6"><span class="s1">. Since the distance from the source increases by <b>at least 2</b> every time an edge becomes critical, the edge (u,v) can become critical at most</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">−</span></p>
<p class="p8"><span class="s1">2</span></p>
<p class="p8"><span class="s1">2</span></p>
<p class="p6"><span class="s1">times. An edge can become critical at most</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">times. Now, there are a total of</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">E</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">edges. Therefore, the number of iterations that the Edmonds-Karp algorithm must go through is</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">E</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">.<span class="Apple-converted-space"> </span></span></p>
<p class="p6"><span class="s1"><b>Conclusion:</b></span></p>
<p class="p6"><span class="s1">Now that we proved the bound on the number of iterations and the bound on each iteration, we get an overall time complexity of</span></p>
<p class="p8"><span class="s1">O</span></p>
<p class="p8"><span class="s1">(</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">V</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">E</span></p>
<p class="p9"><span class="s1">2</span></p>
<p class="p8"><span class="s1">|</span></p>
<p class="p8"><span class="s1">)</span></p>
<p class="p6"><span class="s1">.<span class="Apple-converted-space"> </span></span></p>
<p class="p11"><span class="s1">◻</span></p>
</body>
</html>
